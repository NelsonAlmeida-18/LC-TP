
  TP2 - Problema 1¬∂ <#TP2---Problema-1>


      Grupo 11¬∂ <#Grupo-11>

Nelson Almeida a95652
Nuno Costa a97610

Um programa imperativo pode ser descrito por um modelo do tipo Control
Flow Automaton (CFA) como ilustrado no exemplo da imagem a seguir.

Este programa implementa a multiplica√ß√£o de dois inteiros a,ba,b, fornecidos como ‚Äúinput‚Äù, e com precis√£o limitada a nnbits (fornecido como par√¢metro do programa). Note-se que

  * Existe a possibilidade de alguma das opera√ß√µes do programa produzir
    um erro de ‚Äúoverflow‚Äù.
  * Os n√≥s do grafo representam a√ß√µes que actuam sobre os ‚Äúinputs‚Äù do n√≥
    e produzem um ‚Äúoutput‚Äù com as opera√ß√µes indicadas.
  * Os ramos do grafo representam liga√ß√µes que transferem o ‚Äúoutput‚Äù de
    um nodo para o ‚Äúinput‚Äù do nodo seguinte. Esta transfer√™ncia √©
    condicionada pela satisfa√ß√£o da condi√ß√£o associada ao ramo.

a. Construa um FOTS usando BitVector de tamanho nn que descreva o comportamento deste aut√≥mato. Para isso identifique as
vari√°veis do modelo, o estado inicial e a rela√ß√£o de transi√ß√£o.

b. Verifique seP‚â°(x‚àóy+z=a‚àób)P‚â°(x‚àóy+z=a‚àób)√© um invariante deste comportamento.

automato.png


      Inicializa√ß√£o¬∂ <#Inicializa%C3%A7%C3%A3o>

Come√ßamos por importar o m√≥dulo |pysmt.shortcuts| que disponibiliza as funcionalidades para a utiliza√ß√£o usual de um
SMTsolver. Os tipos est√£o definidos no m√≥dulo |pysmt.typing| de onde temos que importar o tipo INT.

In [51]:

from pysmt.shortcuts import *
from pysmt.typing import INT


      Modela√ß√£o de predicados¬∂ <#Modela%C3%A7%C3%A3o-de-predicados>

O estado inicial √© caracterizado pelo seguinte predicado:

node=0‚àßz=0
node=0‚àßz=0


          Nota:¬∂ <#Nota:>

Estado atual = node
Estado seguinte = node'

As transi√ß√µes poss√≠veis s√£o caracterizadas pelo seguinte predicado:

node=0‚àß(y‚â†0‚àßeven(y))‚àßnode‚Ä≤=1‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z
node=0‚àß(y‚â†0‚àßeven(y))‚àßnode‚Ä≤=1‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z

‚à®
‚à®

node=0‚àßy=0‚àßnode‚Ä≤=2‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z
node=0‚àßy=0‚àßnode‚Ä≤=2‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z

‚à®
‚à®

node=0‚àß(y‚â†0‚àßodd(y))‚àßnode‚Ä≤=3‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z
node=0‚àß(y‚â†0‚àßodd(y))‚àßnode‚Ä≤=3‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z

‚à®
‚à®

node=1‚àßnode‚Ä≤=0‚àßx‚Ä≤=2‚àóx‚àßy‚Ä≤=y/2‚àßz‚Ä≤=z
node=1‚àßnode‚Ä≤=0‚àßx‚Ä≤=2‚àóx‚àßy‚Ä≤=y/2‚àßz‚Ä≤=z

‚à®
‚à®

node=3‚àßnode‚Ä≤=0‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àí1‚àßz‚Ä≤=z+x
node=3‚àßnode‚Ä≤=0‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àí1‚àßz‚Ä≤=z+x

‚à®
‚à®

node=1‚àßnode‚Ä≤=4‚àßoverflow‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z
node=1‚àßnode‚Ä≤=4‚àßoverflow‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z

‚à®
‚à®

node=3‚àßnode‚Ä≤=5‚àßoverflow‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z
node=3‚àßnode‚Ä≤=5‚àßoverflow‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z

‚à®
‚à®

node=4‚àßnode‚Ä≤=4‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z
node=4‚àßnode‚Ä≤=4‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z

‚à®
‚à®

node=5‚àßnode‚Ä≤=5‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z
node=5‚àßnode‚Ä≤=5‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z

‚à®
‚à®

node=2‚àßnode‚Ä≤=2‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z
node=2‚àßnode‚Ä≤=2‚àßx‚Ä≤=x‚àßy‚Ä≤=y‚àßz‚Ä≤=z

A seguinte fun√ß√£o cria a i-√©sima c√≥pia das vari√°veis de estado,
agrupadas num dicion√°rio que nos permite aceder √†s mesmas.

In [52]:

def declare(i, n):
    state = {}
    
    # definir vari√°veis
    state['node'] = Symbol('node' + str(i), INT)
    state['x'] = Symbol('x' + str(i), BVType(n))
    state['y'] = Symbol('y' + str(i), BVType(n))
    state['z'] = Symbol('z' + str(i), BVType(n))
    
    return state

Fun√ß√£o que testa se esse estado √© um poss√≠vel estado inicial do programa.

In [53]:

def init(state, a, b, n):
    return And(
        Equals(state['node'], Int(0)),
        Equals(state['x'], BV(a,n)),
        Equals(state['y'], BV(b,n)),
        Equals(state['z'], BV(0,n))
    )

Fun√ß√µes auxiliares para determinar se uma vari√°vel √© par ou impar.

In [54]:

def even(atual, n):
    return Equals(BVURem(atual['y'], BV(2,n)), BV(0,n))

def odd(atual, n):
    return Not(Equals(BVURem(atual['y'], BV(2,n)), BV(0,n)))

Fun√ß√£o que dados dois poss√≠veis estados do programa, testa se √© poss√≠vel
transitar de um estado para o outro.

In [55]:

def trans(atual, prox, n):
    # ùëõùëúùëëùëí=0 ‚àß ( ùë¶‚â†0 ‚àß ùëíùë£ùëíùëõ(ùë¶) ) ‚àß ùëõùëúùëëùëí‚Ä≤=1 ‚àß ùë•‚Ä≤=ùë• ‚àß ùë¶‚Ä≤=ùë¶ ‚àß ùëß‚Ä≤=ùëß
    t0 = And(
        Equals(atual['node'], Int(0)),
        NotEquals(atual['y'], BV(0,n)),
        even(atual, n),
        Equals(prox['node'], Int(1)),
        Equals(prox['x'], atual['x']),
        Equals(prox['y'], atual['y']),
        Equals(prox['z'], atual['z'])
    )
    
    # ùëõùëúùëëùëí=0 ‚àß ùë¶=0 ‚àß ùëõùëúdùëí‚Ä≤=2 ‚àß ùë•‚Ä≤=ùë• ‚àß ùë¶‚Ä≤=ùë¶ ‚àß ùëß‚Ä≤=ùëß
    t1 = And(
        Equals(atual['node'], Int(0)),
        Equals(atual['y'], BV(0,n)),
        Equals(prox['node'], Int(2)),
        Equals(prox['x'], atual['x']),
        Equals(prox['y'], atual['y']),
        Equals(prox['z'], atual['z'])
    )
    
    # ùëõùëúùëëùëí=0 ‚àß ( ùë¶‚â†0 ‚àß ùëúùëëùëë(ùë¶) ) ‚àß ùëõùëúùëëùëí‚Ä≤=3 ‚àß ùë•‚Ä≤=ùë• ‚àß ùë¶‚Ä≤=ùë¶ ‚àß ùëß‚Ä≤=ùëß
    t2 = And(
        Equals(atual['node'], Int(0)),
        NotEquals(atual['y'], BV(0,n)),
        odd(atual, n),
        Equals(prox['node'], Int(3)),
        Equals(prox['x'], atual['x']),
        Equals(prox['y'], atual['y']),
        Equals(prox['z'], atual['z'])
    )
    
    # ùëõùëúùëëùëí=1 ‚àß ùëõùëúùëëùëí‚Ä≤=0 ‚àß ùë•'=2‚àóùë• ‚àß ùë¶'=ùë¶/2 ‚àß ùëß'=ùëß
    t3 = And(
        LT(Times(BVToNatural(atual['x']),Int(2)), Pow(Int(2), Int(n))),
        Equals(atual['node'], Int(1)),
        Equals(prox['node'], Int(0)),
        Equals(prox['x'], BVMul(atual['x'], BV(2,n))),
        Equals(prox['y'], BVUDiv(atual['y'], BV(2,n))),
        Equals(prox['z'], atual['z'])
    )

    # ùëõùëúùëëùëí=3 ‚àß ùëõùëúùëëùëí‚Ä≤=0 ‚àß ùë•‚Ä≤=ùë• ‚àß ùë¶‚Ä≤=ùë¶‚àí1 ‚àß ùëß‚Ä≤=ùëß+ùë•
    t4 = And(
        LT(Plus(BVToNatural(atual['z']), BVToNatural(atual['x'])), Pow(Int(2), Int(n))),
        Equals(atual['node'], Int(3)),
        Equals(prox['node'], Int(0)),
        Equals(prox['x'], atual['x']),
        Equals(prox['y'], BVSub(atual['y'], BV(1,n))),
        Equals(prox['z'], BVAdd(atual['z'], atual['x']))
    )
      
    # ùëõùëúùëëùëí=1 ‚àß ùëõùëúùëëùëí‚Ä≤=4 ‚àß ùëúùë£ùëíùëüùëìùëôùëúùë§ ‚àß ùë•‚Ä≤=ùë• ‚àß ùë¶‚Ä≤=ùë¶ ‚àß ùëß‚Ä≤=z
    t5 = And(
        GE(Times(BVToNatural(atual['x']),Int(2)), Pow(Int(2), Int(n))),
        Equals(atual['node'], Int(1)),
        Equals(prox['node'], Int(4)),
        Equals(prox['x'], atual['x']),
        Equals(prox['y'], atual['y']),
        Equals(prox['z'], atual['z'])
    )
    
    # ùëõùëúùëëùëí=3 ‚àß ùëõùëúùëëùëí‚Ä≤=5 ‚àß ùëúùë£ùëíùëüùëìùëôùëúùë§ ‚àß ùë•‚Ä≤=ùë• ‚àß ùë¶‚Ä≤=ùë¶ ‚àß ùëß‚Ä≤=ùëß
    t6 = And(
        GE(Plus(BVToNatural(atual['z']), BVToNatural(atual['x'])), Pow(Int(2), Int(n))),
        Equals(atual['node'], Int(3)),
        Equals(prox['node'], Int(5)),
        Equals(prox['x'], atual['x']),
        Equals(prox['y'], atual['y']),
        Equals(prox['z'], atual['z'])
    )
    
    # ùëõùëúùëëùëí=4 ‚àß ùëõùëúùëëùëí‚Ä≤=4 ‚àß ùë•‚Ä≤=ùë• ‚àß ùë¶‚Ä≤=ùë¶ ‚àß ùëß‚Ä≤=ùëß
    t7 = And(
        Equals(atual['node'], Int(4)),
        Equals(prox['node'], Int(4)),
        Equals(prox['x'], atual['x']),
        Equals(prox['y'], atual['y']),
        Equals(prox['z'], atual['z'])
    )
    
    # ùëõùëúùëëùëí=5 ‚àß ùëõùëúùëëùëí‚Ä≤=5 ‚àß ùë•‚Ä≤=ùë• ‚àß ùë¶‚Ä≤=ùë¶ ‚àß ùëß‚Ä≤=ùëß
    t8 = And(
        Equals(atual['node'], Int(5)),
        Equals(prox['node'], Int(5)),
        Equals(prox['x'], atual['x']),
        Equals(prox['y'], atual['y']),
        Equals(prox['z'], atual['z'])
    )
    
    # ùëõùëúùëëùëí=2 ‚àß ùëõùëúùëëùëí‚Ä≤=2 ‚àß ùë•‚Ä≤=ùë• ‚àß ùë¶‚Ä≤=ùë¶ ‚àß ùëß‚Ä≤=ùëß
    t9 = And(
        Equals(atual['node'], Int(2)),
        Equals(prox['node'], Int(2)),
        Equals(prox['x'], atual['x']),
        Equals(prox['y'], atual['y']),
        Equals(prox['z'], atual['z'])
    )
    
    return Or(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9)

Fun√ß√£o que gera um poss√≠vel tra√ßo de execu√ß√£o do programa para k passos.

In [56]:

def gera_traco(declare,init,trans,a_,b_,n_,k_):
    a = a_
    b = b_
    n = n_
    k = k_
    
    #verificar se a e b n√£o s√£o overflow
    if a >= pow(2,n) or b >= pow(2,n): 
        return print("Erro! O valor de 'a' e/ou 'b' n√£o √©/s√£o v√°lido(s)!")
    
    with Solver(name="z3") as s:
    
        trace = [declare(i, n) for i in range(k)]
    
        s.add_assertion(init(trace[0], a, b, n))
    
        for i in range(k-1):
            s.add_assertion(trans(trace[i], trace[i+1], n))
    
        if s.solve():
            for i in range(k):
                print("Passo", i)
                for v in trace[i]:
                    print(v, "=", s.get_value(trace[i][v]))
                print("-----------")

Fun√ß√£o que testa se o invariante P‚â°(x‚àóy+z=a‚àób)P‚â°(x‚àóy+z=a‚àób)√© v√°lido para os k passos.

In [57]:

def testaInvariante(declare,init,trans,a_,b_,n_,k_):
    a = a_
    b = b_
    n = n_
    k = k_
    
    #verificar se a e b n√£o s√£o overflow
    if a >= pow(2,n) or b >= pow(2,n): 
        return print("Erro! O valor de 'a' e/ou 'b' n√£o √©/s√£o v√°lido(s)!")
    
    with Solver(name="z3") as s:
    
        trace = [declare(i, n) for i in range(k+1)]
    
        s.push()
        s.add_assertion(init(trace[0], a, b, n))
    
        for i in range(k):
            s.add_assertion(trans(trace[i], trace[i+1], n))
            
        s.add_assertion(Or([Not(invariante(trace[i], a, b, n)) for i in range(k)]))
    
        if s.solve():
            print("A propriedade do invariante n√£o √© v√°lida nos primeiros", k, "passos")
            
            for v in trace[0]:
                print(v, "=", s.get_values([trace[0][v]]))
            return
        
        s.pop()
        s.push()
        
        for i in range(k):
            s.add_assertion(invariante(trace[i], a, b, n))
            s.add_assertion(trans(trace[i], trace[i+1], n))
            
        s.add_assertion(Not(invariante(trace[i], a, b, n)))
        
        if s.solve():
            print("A propriedade do invariante n√£o se verifica")
            
            for v in trace[0]:
                print(v, "=", s.get_value(trace[0][v]))
            return
    
        print("A propriedade do invariante √© v√°lida nos", k, "passos")
        
        
def invariante(state,a,b,n):
    return Equals(BVAdd(BVMul(state['x'], state['y']), state['z']), BVMul(BV(a, n), BV(b, n)))

Exemplos:

In [60]:

# a = 5, b = 2, n = 5, k = 10
gera_traco(declare,init,trans,5,2,5,10)
testaInvariante(declare,init,trans,5,2,5,10)

Passo 0
node = 0
x = 5_5
y = 2_5
z = 0_5
-----------
Passo 1
node = 1
x = 5_5
y = 2_5
z = 0_5
-----------
Passo 2
node = 0
x = 10_5
y = 1_5
z = 0_5
-----------
Passo 3
node = 3
x = 10_5
y = 1_5
z = 0_5
-----------
Passo 4
node = 0
x = 10_5
y = 0_5
z = 10_5
-----------
Passo 5
node = 2
x = 10_5
y = 0_5
z = 10_5
-----------
Passo 6
node = 2
x = 10_5
y = 0_5
z = 10_5
-----------
Passo 7
node = 2
x = 10_5
y = 0_5
z = 10_5
-----------
Passo 8
node = 2
x = 10_5
y = 0_5
z = 10_5
-----------
Passo 9
node = 2
x = 10_5
y = 0_5
z = 10_5
-----------
A propriedade do invariante √© v√°lida nos 10 passos

In [61]:

# a = 18, b = 4, n = 5, k = 5
gera_traco(declare,init,trans,18,4,5,5)
testaInvariante(declare,init,trans,18,4,5,5)

Passo 0
node = 0
x = 18_5
y = 4_5
z = 0_5
-----------
Passo 1
node = 1
x = 18_5
y = 4_5
z = 0_5
-----------
Passo 2
node = 4
x = 18_5
y = 4_5
z = 0_5
-----------
Passo 3
node = 4
x = 18_5
y = 4_5
z = 0_5
-----------
Passo 4
node = 4
x = 18_5
y = 4_5
z = 0_5
-----------
A propriedade do invariante √© v√°lida nos 5 passos

In [62]:

# a = 32, b = 4, n = 5, k = 5
gera_traco(declare,init,trans,32,4,5,5)
testaInvariante(declare,init,trans,32,4,5,5)

Erro! O valor de 'a' e/ou 'b' n√£o √©/s√£o v√°lido(s)!
Erro! O valor de 'a' e/ou 'b' n√£o √©/s√£o v√°lido(s)!

No exemplo anterior ocrorreu erro, porque para n = 5 bits √© impossiv√©l
representar a = 32 (overflow).

In [63]:

gera_traco(declare,init,trans,2,1,5,10)

Passo 0
node = 0
x = 2_5
y = 1_5
z = 0_5
-----------
Passo 1
node = 3
x = 2_5
y = 1_5
z = 0_5
-----------
Passo 2
node = 0
x = 2_5
y = 0_5
z = 2_5
-----------
Passo 3
node = 2
x = 2_5
y = 0_5
z = 2_5
-----------
Passo 4
node = 2
x = 2_5
y = 0_5
z = 2_5
-----------
Passo 5
node = 2
x = 2_5
y = 0_5
z = 2_5
-----------
Passo 6
node = 2
x = 2_5
y = 0_5
z = 2_5
-----------
Passo 7
node = 2
x = 2_5
y = 0_5
z = 2_5
-----------
Passo 8
node = 2
x = 2_5
y = 0_5
z = 2_5
-----------
Passo 9
node = 2
x = 2_5
y = 0_5
z = 2_5
-----------

